import { encodeMove, decodeMove, rowColToSquare } from './util.js';
import {
  Color,
  MoveType,
  PieceType,
  Square,
  CastlingRights,
} from './engine.js';
import Engine from './engine.js';

function createGame(fen: string, color: Color) {
  const engine = new Engine();
  engine.LoadFEN(fen);

  // user piece color decided at start of game and doesnt change
  const userColor = color;
  // legal moves set for O(1) lookup to check if user move is legal
  let legalMovesSet = new Set<number>();
  let fromToMap = new Map<number, number[]>();

  function buildMoveSet() {
    legalMovesSet.clear();
    fromToMap.clear();

    const legalMoves = engine.GenerateLegalMoves();
    legalMoves.forEach((move) => {
      legalMovesSet.add(move);

      const fromSq = (move >> 6) & 63;
      const toSq = move & 63;

      if (!fromToMap.has(fromSq)) {
        fromToMap.set(fromSq, []);
      }
      fromToMap.get(fromSq)!.push(toSq);
    });

    console.log(legalMovesSet);
    console.log(fromToMap);
  }

  function getMovesFromSq(sq: number) {
    if (fromToMap.size == 0 || !fromToMap.has(sq)) return [];
    return fromToMap.get(sq);
  }

  function getMoveType(fr: number, fc: number, tr: number, tc: number) {
    const fromSq = rowColToSquare(fr, fc);
    const toSq = rowColToSquare(tr, tc);
    const fromPiece = getPieceOnSq(fromSq);
    const toPiece = getPieceOnSq(toSq);
    console.log(`from: ${fromPiece} to: ${toPiece}`);
    // by default a quite move
    let type = MoveType.Quiet;

    if (!fromPiece) return type;

    // if either side pawn reaches their respective end of the board (7 or 0) then promote
    if (fromPiece.Type === PieceType.Pawn && (tr === 7 || tr === 0)) {
      type = toPiece ? MoveType.QueenPromotionCapture : MoveType.QueenPromotion;
    }
    // currently only allows castling by selecting the king then the rook on
    // either queen or king side. Correctly it should allow catling by selecting
    // the eihter the G or C file or the rooks. So to check if it's a castling
    // move check if pieceAt is a rook
    else if (
      toPiece &&
      fromPiece.Color === toPiece.Color &&
      fromPiece.Type === PieceType.King &&
      toPiece.Type === PieceType.Rook
    ) {
      const isKingSide = tc > fc;

      const isWhiteCastle =
        fromSq === Square.e1 && (toSq === Square.h1 || toSq === Square.a1);

      const isBlackCastle =
        fromSq === Square.e8 && (toSq === Square.h8 || toSq === Square.a8);

      if (isWhiteCastle || isBlackCastle) {
        type = isKingSide ? MoveType.KingCastle : MoveType.QueenCastle;
      }
    }
    // if taget piece is same as enpassant square
    else if (
      fromPiece.Type === PieceType.Pawn &&
      engine.BoardState.EnPassSq === toSq
    ) {
      type = MoveType.EPCapture;
    }
    // none of above check if target is not empty
    else if (toPiece) {
      type = MoveType.Capture;
    }

    return type;
  }

  function tryUserMove(fr: number, fc: number, tr: number, tc: number) {
    const moveType = getMoveType(fr, fc, tr, tc);
    const move = encodeMove(fr, fc, tr, tc, moveType);

    // checking if the user move exist in leagal moves set generated by engine
    if (legalMovesSet.has(move)) {
      engine.MakeMove(move);
      return true;
    } else {
      return false;
    }
  }

  function makeComputerMove() {
    const bestMove = engine.Search(10);
    const { from, to } = decodeMove(bestMove);
    engine.MakeMove(bestMove);
    console.log(`Computer Move: ${bestMove} [${from}],[${to}]\n`);
  }

  function checkGameOver() {
    const gameState = engine.isGameOver(legalMovesSet.size);

    if (gameState.over) {
      console.log(`\n=== GAME OVER ===`);
      console.log(`Result: ${gameState.reason}`);

      if (gameState.reason === 'checkmate') {
        const winner =
          engine.BoardState.SideToMove === Color.White ? 'Black' : 'White';
        console.log(`${winner} wins by checkmate!`);
      } else if (gameState.reason === 'stalemate') {
        console.log('Draw by stalemate!');
      } else {
        console.log(`Draw by ${gameState.reason}!`);
      }

      console.log('=================\n');
    }

    return gameState.over;
  }

  function getPieceOnSq(square: number) {
    return engine.BoardState.Squares[square] ?? null;
  }

  function hasCastlingRights(userColor: Color) {
    let hasRights = true;
    if (userColor == Color.White) {
      hasRights =
        (engine.BoardState.CastlingRights & CastlingRights.WhiteKingside) !==
          0 &&
        (engine.BoardState.CastlingRights & CastlingRights.WhiteQueenside) !==
          0;
    } else {
      hasRights =
        (engine.BoardState.CastlingRights & CastlingRights.BlackKingside) !==
          0 &&
        (engine.BoardState.CastlingRights & CastlingRights.BlackQueenside) !==
          0;
    }

    return hasRights;
  }

  return {
    get isWhiteTurn() {
      return engine.BoardState.SideToMove == Color.White;
    },
    get isUserTurn() {
      return engine.BoardState.SideToMove == userColor;
    },
    printBoard() {
      engine.PrintBoard();
    },
    checkGameOver,
    makeComputerMove,
    tryUserMove,
    buildMoveSet,
    getMovesFromSq,
    getPieceOnSq,
  };
}

export default createGame;
