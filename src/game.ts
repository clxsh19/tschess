import { encodeMove } from './util.js';
import { Color, MoveType, PieceType, Square, Piece } from './engine.js';
import Engine from './engine.js';

function createGame(fen: string, color: Color) {
  const engine = new Engine();
  engine.LoadFEN(fen);

  // user piece color decided at start of game and doesnt change
  const userColor = color;
  // legal moves set for O(1) lookup to check if user move is legal
  let legalMovesSet = new Set<number>();
  let fromToMap = new Map<number, number[]>();

  function buildMoveSet() {
    legalMovesSet.clear();
    fromToMap.clear();

    const legalMoves = engine.GenerateLegalMoves();
    legalMoves.forEach((move) => {
      legalMovesSet.add(move);

      const fromSq = (move >> 6) & 63;
      const toSq = move & 63;

      if (!fromToMap.has(fromSq)) {
        fromToMap.set(fromSq, []);
      }
      fromToMap.get(fromSq)!.push(toSq);
    });
  }

  function getMovesFromSq(sq: number) {
    if (fromToMap.size == 0 || !fromToMap.has(sq)) return [];
    return fromToMap.get(sq);
  }

  function getUserMoveType(
    fromSq: Square,
    toSq: Square,
    fromPiece: Piece,
    toPiece: Piece | null,
  ) {
    console.log(`from: ${fromPiece.Type} to: ${toPiece?.Type}`);
    // let type = null;
    // by default a quite move
    let type = MoveType.Quiet;

    if (!fromPiece) return null;

    // pawn promotion, pawn reaches the 0 or 8th rank
    if (
      fromPiece.Type === PieceType.Pawn &&
      ((fromPiece.Color === Color.White &&
        toSq >= Square.a8 &&
        toSq <= Square.h8) ||
        (fromPiece.Color === Color.Black &&
          toSq >= Square.a1 &&
          toSq <= Square.h1))
    ) {
      type = toPiece ? MoveType.QueenPromotionCapture : MoveType.QueenPromotion;
    }
    // currently only allows castling by selecting the king then the rook on
    // either queen or king side.
    else if (
      toPiece &&
      fromPiece.Color === toPiece.Color &&
      fromPiece.Type === PieceType.King &&
      toPiece.Type === PieceType.Rook
    ) {
      const isKingSide = toSq > fromSq;
      const isWhiteCastle =
        fromSq === Square.e1 && (toSq === Square.h1 || toSq === Square.a1);
      const isBlackCastle =
        fromSq === Square.e8 && (toSq === Square.h8 || toSq === Square.a8);

      if (isWhiteCastle || isBlackCastle) {
        type = isKingSide ? MoveType.KingCastle : MoveType.QueenCastle;
      }
    }
    // if taget piece is same as enpassant square
    else if (
      fromPiece.Type === PieceType.Pawn &&
      engine.BoardState.EnPassSq === toSq
    ) {
      type = MoveType.EPCapture;
    }
    // caputre move
    else if (toPiece) {
      type = MoveType.Capture;
    }

    return type;
  }

  function validateUserMove(
    fr: number,
    fc: number,
    tr: number,
    tc: number,
    moveType: MoveType | null,
  ) {
    if (moveType === null) return false;
    const move = encodeMove(fr, fc, tr, tc, moveType);

    // checking if the user move exist in leagal moves set generated by engine
    if (legalMovesSet.has(move)) {
      return move;
    } else {
      return false;
    }
  }

  function makeComputerMove() {
    const bestMove = engine.Search(10);
    engine.MakeMove(bestMove);
    console.log(`Computer Move: ${bestMove}`);
  }

  function checkGameOver() {
    const gameState = engine.isGameOver(legalMovesSet.size);

    if (gameState.over) {
      console.log(`\n=== GAME OVER ===`);
      console.log(`Result: ${gameState.reason}`);

      if (gameState.reason === 'checkmate') {
        const winner =
          engine.BoardState.SideToMove === Color.White ? 'Black' : 'White';
        console.log(`${winner} wins by checkmate!`);
      } else if (gameState.reason === 'stalemate') {
        console.log('Draw by stalemate!');
      } else {
        console.log(`Draw by ${gameState.reason}!`);
      }

      console.log('=================\n');
    }

    return gameState.over;
  }

  function getPieceOnSq(square: number) {
    return engine.BoardState.Squares[square] ?? null;
  }

  function makeMove(move: number) {
    engine.MakeMove(move);
  }

  return {
    get isUserTurn() {
      return engine.BoardState.SideToMove == userColor;
    },

    checkGameOver,
    makeComputerMove,
    validateUserMove,
    makeMove,
    buildMoveSet,
    getMovesFromSq,
    getUserMoveType,
    getPieceOnSq,
  };
}

export default createGame;
