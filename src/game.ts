import uiBoard from './uiBoard.js';
import { encodeMove, decodeMove, rowColToSquare } from './util.js';
import { Color, MoveType } from './engine.js';
import Engine from './engine.js';

function createGame(fen: string, color: Color) {
  const gameBoard = uiBoard();
  const engine = new Engine();
  engine.LoadFEN(fen);
  gameBoard.LoadFen(fen);

  // user piece color decided at start of game and doesnt change
  const userColor = color;
  // legal moves set for O(1) lookup to check if user move is legal
  let legalMovesSet = new Set<number>();
  let fromToMap = new Map<number, number[]>();

  function buildMoveSet() {
    legalMovesSet.clear();
    fromToMap.clear();

    const legalMoves = engine.GenerateLegalMoves();
    legalMoves.forEach((move) => {
      legalMovesSet.add(move);

      const fromSq = (move >> 6) & 63;
      const toSq = move & 63;

      if (!fromToMap.has(fromSq)) {
        fromToMap.set(fromSq, []);
      }
      fromToMap.get(fromSq)!.push(toSq);
    });

    console.log(legalMovesSet);
    console.log(fromToMap);
  }

  function getMovesFromSq(sq: number) {
    if (fromToMap.size == 0 || !fromToMap.has(sq)) return -1;
    return fromToMap.get(sq);
  }

  function getMoveType(fr: number, fc: number, tr: number, tc: number) {
    // by default a quite move
    let type = MoveType.Quiet;
    const pieceFrom = gameBoard.getPiece(fr, fc);
    const pieceTo = gameBoard.getPiece(tr, tc);
    console.log(`piece ${pieceFrom} to ${pieceTo}`);

    // if either side pawn reaches their respective end of the board (7 or 0) then promote
    if ((pieceFrom == 'p' && tr == 7) || (pieceFrom == 'P' && tr == 0)) {
      type =
        pieceTo !== '.'
          ? MoveType.QueenPromotionCapture
          : MoveType.QueenPromotion;
    }
    // currently only allows castling by selecting the king then the rook on
    // either queen or king side. Correctly it should allow catling by selecting
    // the eihter the G or C file or the rooks. So to check if it's a castling
    // move check if pieceAt is a rook
    else if (
      (pieceFrom == 'k' && pieceTo == 'r') ||
      (pieceFrom == 'K' && pieceTo == 'R')
    ) {
      const isKingSide = tc > fc;
      const isWhiteCastle =
        fr === 7 && fc === 4 && tr === 7 && (tc === 7 || tc === 0);
      const isBlackCastle =
        fr === 0 && fc === 4 && tr === 0 && (tc === 7 || tc === 0);
      if (isWhiteCastle || isBlackCastle) {
        type = isKingSide ? MoveType.KingCastle : MoveType.QueenCastle;
      }
    }
    // if taget piece is same as enpassant square
    else if (
      (pieceFrom == 'p' || pieceFrom == 'P') &&
      engine.BoardState.EnPassSq == rowColToSquare(tr, tc)
    ) {
      type = MoveType.EPCapture;
    }
    // none of above check if target is not empty
    else if (pieceTo !== '.') {
      type = MoveType.Capture;
    }

    return type;
  }

  function executeMove(
    fr: number,
    fc: number,
    tr: number,
    tc: number,
    move: number,
  ) {
    engine.MakeMove(move);
    gameBoard.makeMove(fr, fc, tr, tc);
  }

  function isUserPiece(r: number, c: number) {
    return userColor == gameBoard.getPieceColor(r, c);
  }

  function tryUserMove(fr: number, fc: number, tr: number, tc: number) {
    const moveType = getMoveType(fr, fc, tr, tc);
    const move = encodeMove(fr, fc, tr, tc, moveType);
    console.log(`Move-Key: ${move}`);

    // checking if the user move exist in leagal moves set generated by  engine
    if (legalMovesSet.has(move)) {
      // executeMove(fr, fc, tr, tc, move);
      return true;
    } else {
      console.log('Error: ', fr, fc, ',', tr, tc);
      console.log(legalMovesSet);
      return false;
    }
  }

  function makeComputerMove() {
    const bestMove = engine.Search(10);
    const { from, to } = decodeMove(bestMove);
    executeMove(from[0], from[1], to[0], to[1], bestMove);
    console.log(`Computer Move: ${bestMove} [${from}],[${to}]\n`);
  }

  function checkGameOver() {
    const gameState = engine.isGameOver(legalMovesSet.size);

    if (gameState.over) {
      console.log(`\n=== GAME OVER ===`);
      console.log(`Result: ${gameState.reason}`);

      if (gameState.reason === 'checkmate') {
        const winner =
          engine.BoardState.SideToMove === Color.White ? 'Black' : 'White';
        console.log(`${winner} wins by checkmate!`);
      } else if (gameState.reason === 'stalemate') {
        console.log('Draw by stalemate!');
      } else {
        console.log(`Draw by ${gameState.reason}!`);
      }

      console.log('=================\n');
    }

    return gameState.over;
  }

  return {
    get isWhiteTurn() {
      return engine.BoardState.SideToMove == Color.White;
    },
    printBoard() {
      engine.PrintBoard();
    },
    checkGameOver,
    makeComputerMove,
    tryUserMove,
    buildMoveSet,
    getPiece: gameBoard.getPiece,
    isUserPiece,
    getMovesFromSq,
  };
}

export default createGame;
